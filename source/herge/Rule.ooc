import io/[File, FileWriter, Writer]
import structs/[ArrayList, HashMap, Stack]
import Grammar, GrammarReader, BuildParams, Herge

Trail: class {

    grammar: Grammar
    params: BuildParams

    stack := Stack<Rule> new()

    init: func (=grammar, =params) {
          
    }

}


/**
 * A rule can be matched against some text
 */
Rule: abstract class {

    seed := static 0

    resolve: func (g: Grammar) {
        Exception new("Class %s is doing nothing to resolve! Aborting" format(class name)) throw()
    }

    toString: abstract func -> String

    _: String {
        get {
            toString()
        }
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writePrologue! Aborting" format(class name)) throw()
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writeInSitu! Aborting" format(class name)) throw()
    }

    genName: func -> String {
        seed += 1
        "parseRule%d" format(seed)
    }

    writeSub: func (trail: Trail, writer: Writer, sub: Rule) -> String {
        name := genName()
        writer writef("%s: static func (_reader: GrammarReader) -> Token {\n", name)
        writer write ("_start := _reader mark()\n")
        writer write ("_end  : Long = -1\n")
        sub writeInSitu(trail, writer)
        writer write ("  Token new(_reader, _start, _end)\n")
        writer write ("}\n\n")
        name
    }

}

/**
 * Each TopRule generates an .ooc file
 */
TopRule: class extends Rule {

    name: String
    paramNames: ArrayList<String>
    params := HashMap<String, Rule> new()

    instance: Rule

    init: func (=name, =paramNames, =instance) {
    }

    resolve: func (g: Grammar) {
        instance resolve(g)
    }

    toString: func -> String {
        paramRepr := paramNames ? "<" + paramNames join(", ") + ">" : ""
        "%s%s := %s" format(name, paramRepr, instance _)
    }

    writeFile: func (g: Grammar, params: BuildParams) {
        prefixedName := params prefix + name replaceAll('-', '_') 
        outFile := File new(params outPath, prefixedName + ".ooc")

        if(!outFile parent() exists?()) {
            outFile parent() mkdirs()
        }

        "Writing to %s" printfln(outFile path)
        writer := FileWriter new(outFile)

        trail := Trail new(g, params)

        // write imports
        writer write ("import GrammarReader, Token\n\n")


        writer write ("/**\n")
        writer writef(" * Class %s, generated by herge v%s\n", name, Herge version)
        writer writef(" * Generated from file %s, don't edit by hand :)\n", g path)
        writer write (" */\n")
        writer writef("%s: class extends Token {\n", prefixedName)
        writer write ("  init: super func\n")
        instance writePrologue(trail, writer)

        writer write ("  parse: static func (_reader: GrammarReader) -> Token {\n")
        writer write ("     _start: Long  = _reader marker\n")
        writer write ("     _end: Long  = -1\n")
        instance writeInSitu(trail, writer)
        writer write ("     new(_reader, _start, _end)\n")
        writer write ("  }\n")
        writer write ("}\n\n")

        writer close()
    }

}

/**
 * "some string here"
 */
StringRule: class extends Rule {

    symbol: String

    init: func(=symbol) {}

    toString: func -> String { "\"%s\"" format(symbol) }
    
    resolve: func (g: Grammar) {
        // nothing to do
    }

    writePrologue: func (trail: Trail, writer: Writer) {
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        writer writef("     // %s\n", toString())
        writer writef("     for(c in \"%s\") if(_reader read() != c) {\n", symbol)
        writer write ("       _reader reset(_start)\n")
        writer write ("       return null\n")
        writer write ("     }\n")
        writer write ("     _end = _reader mark()\n")
    }

}

/**
 * somerule<subrule, othersubrule>
 */
InstanceRule: class extends Rule {

    refName: String
    ref: Rule
    params := ArrayList<Rule> new()

    init: func (=refName) {}

    toString: func -> String {
        paramRepr := params empty?() ? "" : "<" + params map(|x| x _) join(", ") + ">"
        "%s%s" format(refName, paramRepr)
    }

    resolve: func (g: Grammar) {
        ref = g rules[refName]
        if(!ref) {
            // This currently fail on generic parameters - we need some kind of stack here
            //Exception new("Undefined rule %s" format(refName)) throw()
        }
    }

}

/**
 * somename: somerule
 */
NamedRule: class extends Rule {

    name: String
    instance: Rule

    init: func(=name, =instance)

    toString: func -> String {
        "%s: %s" format(name, instance _)
    }

    resolve: func (g: Grammar) {
        instance resolve(g)
    }

}

/**
 * [someregexpclass]
 */
ClassRule: class extends Rule {

    expr: String

    init: func(=expr) {}

    toString: func -> String {
        expr
    }

    resolve: func (g: Grammar) {
        // nothing to resolve here.
    }

}

/**
 * somerule? 
 */
QueryRule: class extends Rule {

    rule: Rule

    init: func(=rule) {}

    toString: func -> String {
        "%s?" format(rule _)
    }

    resolve: func (g: Grammar) {
        rule resolve(g)
    }
}

/**
 * somerule*
 */
StarRule: class extends Rule {

    rule: Rule

    init: func(=rule) {}

    toString: func -> String {
        "%s*" format(rule _)
    }

    resolve: func (g: Grammar) {
        rule resolve(g)
    }

}

/**
 * somerule+
 */
PlusRule: class extends Rule {

    rule: Rule

    init: func(=rule) {}

    toString: func -> String {
        "%s*" format(rule _)
    }

    resolve: func (g: Grammar) {
        rule resolve(g)
    }

}

/**
 * leftRule | rightRule
 */
BarRule: class extends Rule {

    leftRule, rightRule: Rule
    sub1, sub2: String

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s | %s" format(leftRule _, rightRule _)
    }

    resolve: func (g: Grammar) {
        leftRule resolve(g)
        rightRule resolve(g)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        leftRule writePrologue(trail, writer)
        rightRule writePrologue(trail, writer)
        sub1 = writeSub(trail, writer, leftRule)
        sub2 = writeSub(trail, writer, rightRule)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub1)
        writer writef("if(%s) return %s\n", tok1, tok1)
        writer writef("%s := %s(_reader)\n", tok2, sub2)
        writer writef("if(%s) return %s\n", tok2, tok2)
        writer write ("return null\n")
    }


}

/**
 * somerule someotherrule
 * Must match somerule, then someotherrule
 */
AndRule: class extends Rule {

    leftRule, rightRule: Rule
    sub1, sub2: String

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s %s" format(leftRule _, rightRule _)
    }

    resolve: func (g: Grammar) {
        leftRule resolve(g)
        rightRule resolve(g)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        leftRule writePrologue(trail, writer)
        rightRule writePrologue(trail, writer)
        sub1 = writeSub(trail, writer, leftRule)
        sub2 = writeSub(trail, writer, rightRule)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub1)
        writer writef("if(%s) {\n", tok1)
        writer writef("  %s := %s(_reader)\n", tok2, sub2)
        writer writef("  if(%s) return %s merge(%s)\n", tok2, tok1, tok2)
        writer write ("}\n")
        writer write ("return null\n")
    }

}


