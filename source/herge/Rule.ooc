import io/[File, FileWriter, Writer]
import structs/[ArrayList, HashMap, Stack]
import Grammar, GrammarReader, BuildParams, Herge

Trail: class {

    grammar: Grammar
    params: BuildParams

    rule: Rule
    parent: This

    init: func (=grammar, =params, =rule, parent := null) {
        this parent = parent
    }

    push: func (child: Rule) {
        new(grammar, params, child, this)
    }

    find: func <T> (T: Class) -> T {
        match (rule class) {
            case T =>
                return rule
            case =>
                if(parent) {
                    return parent find(T)
                }
        }
        null
    }

}


/**
 * A rule can be matched against some text
 */
Rule: abstract class {

    seed := static 0

    resolve: func (trail: Trail) {
        Exception new("Class %s is doing nothing to resolve! Aborting" format(class name)) throw()
    }

    escape: static func (s: String) -> String {
        s replaceAll('-', '_') 
    }

    toString: abstract func -> String

    _: String {
        get {
            toString()
        }
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writePrologue! Aborting" format(class name)) throw()
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writeInSitu! Aborting" format(class name)) throw()
    }

    genName: func -> String {
        seed += 1
        "parseRule%d" format(seed)
    }

    writeSub: func (trail: Trail, writer: Writer, sub: Rule) -> String {
        name := genName()
        writer writef("%s: static func (_reader: GrammarReader) -> Token {\n", name)
        sub writeInSitu(trail, writer)
        writer write ("}\n\n")
        name
    }

}

/**
 * Each TopRule generates an .ooc file
 */
TopRule: class extends Rule {

    name: String
    paramNames: ArrayList<String>
    params := HashMap<String, Rule> new()
    deps := ArrayList<String> new()

    instance: Rule

    init: func (=name, =paramNames, =instance) {
    }

    resolve: func (trail: Trail) {
        deps add("GrammarReader"). add("Token")
        instance resolve(trail)
    }

    addDep: func (s: String) {
        if(!deps contains?(s)) deps add(s)
    }

    toString: func -> String {
        paramRepr := paramNames ? "<" + paramNames join(", ") + ">" : ""
        "%s%s := %s" format(name, paramRepr, instance _)
    }

    writeFile: func (g: Grammar, params: BuildParams) {
        prefixedName := params prefix + escape(name)
        outFile := File new(params outPath, prefixedName + ".ooc")

        if(!outFile parent() exists?()) {
            outFile parent() mkdirs()
        }

        "Writing to %s" printfln(outFile path)
        writer := FileWriter new(outFile)

        trail := Trail new(g, params, this)

        // write imports
        allImports := deps map(|x| escape(x)) join(", ")
        writer writef("import %s\n\n", allImports)

        writer write ("/**\n")
        writer writef(" * Class %s, generated by herge v%s\n", name, Herge version)
        writer writef(" * Generated from file %s, don't edit by hand :)\n", g path)
        writer write (" */\n")
        writer writef("%s: class extends Token {\n", prefixedName)
        writer write ("  init: super func\n")
        instance writePrologue(trail, writer)
        writer write ("  parse: static func (_reader: GrammarReader) -> Token {\n")
        instance writeInSitu(trail, writer)
        writer write ("  }\n")
        writer write ("}\n\n")

        writer close()
    }

}

/**
 * "some string here"
 */
StringRule: class extends Rule {

    symbol: String

    init: func(=symbol) {}

    toString: func -> String { "\"%s\"" format(symbol) }
    
    resolve: func (trail: Trail) {
        // nothing to do
    }

    writePrologue: func (trail: Trail, writer: Writer) {
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        writer writef("     // %s\n", toString())
        writer write ("     _start := _reader mark()\n")
        writer writef("     for(c in \"%s\") if(_reader read() != c) {\n", symbol)
        writer write ("       _reader reset(_start)\n")
        writer write ("       return null\n")
        writer write ("     }\n")
        writer write ("     _end := _reader mark()\n")
        writer write ("     Token new(_reader, _start, _end)\n")
    }

}

/**
 * somerule<subrule, othersubrule>
 */
InstanceRule: class extends Rule {

    refName: String
    ref: Rule
    params := ArrayList<Rule> new()

    init: func (=refName) {}

    toString: func -> String {
        paramRepr := params empty?() ? "" : "<" + params map(|x| x _) join(", ") + ">"
        "%s%s" format(refName, paramRepr)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        writer writef("%s parse(_reader)", escape(refName))
    }

    resolve: func (trail: Trail) {
        top := trail find(TopRule)
        top addDep(refName)
        ref = trail grammar rules[refName]
        if(!ref) {
            // This currently fail on generic parameters - we need some kind of stack here
            //Exception new("Undefined rule %s" format(refName)) throw()
        }
    }

}

/**
 * somename: somerule
 */
NamedRule: class extends Rule {

    name: String
    instance: Rule

    init: func(=name, =instance)

    toString: func -> String {
        "%s: %s" format(name, instance _)
    }

    resolve: func (trail: Trail) {
        instance resolve(trail)
    }

}

/**
 * [someregexpclass]
 */
ClassRule: class extends Rule {

    expr: String

    init: func(=expr) {}

    toString: func -> String {
        expr
    }

    resolve: func (trail: Trail) {
        // nothing to resolve here.
    }

}

UnaryRule: abstract class extends Rule {

    rule: Rule
    sub: String

    init: func (=rule)

    resolve: func (trail: Trail) {
        rule resolve(trail)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        rule writePrologue(trail, writer)
        sub = writeSub(trail, writer, rule)
    }

}

/**
 * somerule? 
 */
QueryRule: class extends UnaryRule {

    init: super func

    toString: func -> String {
        "%s?" format(rule _)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub)
        writer writef("%s ? %s : _reader emptyToken()\n", tok1)
    }

}

/**
 * somerule*
 */
StarRule: class extends UnaryRule {

    init: super func

    toString: func -> String {
        "%s*" format(rule _)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub)
        writer writef("if(!%s) return _reader emptyToken()\n", tok1, sub)
        writer writef("while (%s) {\n", tok1)
        writer writef("  %s := %s(_reader)\n", tok2, sub)
        writer writef("  if(%s) { %s = %s merge(%s) } else { break }\n", tok2, tok1, tok1, tok2)
        writer write ("}\n")
        writer writef("%s\n", tok1)
    }


}

/**
 * somerule+
 */
PlusRule: class extends UnaryRule {

    init: super func

    toString: func -> String {
        "%s*" format(rule _)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub)
        writer writef("while (%s) {\n", tok1)
        writer writef("  %s := %s(_reader)\n", tok2, sub)
        writer writef("  if(%s) { %s = %s merge(%s) } else { break }\n", tok2, tok1, tok1, tok2)
        writer write ("}\n")
        writer writef("%s\n", tok1)
    }

}

/**
 * leftRule | rightRule
 */
AlternativeRule: class extends Rule {

    leftRule, rightRule: Rule
    sub1, sub2: String

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s | %s" format(leftRule _, rightRule _)
    }

    resolve: func (trail: Trail) {
        leftRule resolve(trail)
        rightRule resolve(trail)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        leftRule writePrologue(trail, writer)
        rightRule writePrologue(trail, writer)
        sub1 = writeSub(trail, writer, leftRule)
        sub2 = writeSub(trail, writer, rightRule)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub1)
        writer writef("if(%s) return %s\n", tok1, tok1)
        writer writef("return %s(_reader)\n", sub2)
    }


}

/**
 * somerule someotherrule
 * Must match somerule, then someotherrule
 */
SequenceRule: class extends Rule {

    leftRule, rightRule: Rule
    sub1, sub2: String

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s %s" format(leftRule _, rightRule _)
    }

    resolve: func (trail: Trail) {
        leftRule resolve(trail)
        rightRule resolve(trail)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        leftRule writePrologue(trail, writer)
        rightRule writePrologue(trail, writer)
        sub1 = writeSub(trail, writer, leftRule)
        sub2 = writeSub(trail, writer, rightRule)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub1)
        writer writef("if(%s) {\n", tok1)
        writer writef("  %s := %s(_reader)\n", tok2, sub2)
        writer writef("  if(%s) return %s merge(%s)\n", tok2, tok1, tok2)
        writer write ("}\n")
        writer write ("null\n")
    }

}


