import structs/[ArrayList, HashMap, Stack]
import text/[Opts, Regexp]
import os/Env
import io/[File, FileWriter, Writer]

import GrammarReader

/**
 * A rule can be matched against some text
 */
Rule: abstract class {

    seed := static 0

    resolve: func (g: Grammar) {
        Exception new("Class %s is doing nothing to resolve! Aborting" format(class name)) throw()
    }

    toString: abstract func -> String

    _: String {
        get {
            toString()
        }
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writePrologue! Aborting" format(class name)) throw()
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        Exception new("Class %s is doing nothing to writeInSitu! Aborting" format(class name)) throw()
    }

    genName: func -> String {
        seed += 1
        "parseRule%d" format(seed)
    }

    writeSub: func (trail: Trail, writer: Writer, sub: Rule) -> String {
        name := genName()
        writer writef("%s: static func (_reader: GrammarReader) -> Token {\n", name)
        writer write ("_start := _reader mark()\n")
        writer write ("_end  : Long = -1\n")
        sub writeInSitu(trail, writer)
        writer write ("  Token new(_reader, _start, _end)")
        writer write ("}\n\n")
        name
    }

}

Trail: class {

    grammar: Grammar
    params: BuildParams

    stack := Stack<Rule> new()

    init: func (=grammar, =params) {
          
    }

}

TopRule: class extends Rule {

    name: String
    paramNames: ArrayList<String>
    params := HashMap<String, Rule> new()

    instance: Rule

    init: func (=name, =paramNames, =instance) {
    }

    resolve: func (g: Grammar) {
        instance resolve(g)
    }

    toString: func -> String {
        paramRepr := paramNames ? "<" + paramNames join(", ") + ">" : ""
        "%s%s := %s" format(name, paramRepr, instance _)
    }

    writeFile: func (g: Grammar, params: BuildParams) {
        prefixedName := params prefix + name replaceAll('-', '_') 
        outFile := File new(params outPath, prefixedName + ".ooc")

        if(!outFile parent() exists?()) {
            outFile parent() mkdirs()
        }

        "Writing to %s" printfln(outFile path)
        writer := FileWriter new(outFile)

        trail := Trail new(g, params)

        // write imports
        writer write ("import GrammarReader, Token\n\n")


        writer write ("/**\n")
        writer writef(" * Class %s, generated by herge v%s\n", name, Herge version)
        writer writef(" * Generated from file %s, don't edit by hand :)\n", g path)
        writer write (" */\n")
        writer writef("%s: class extends Token {\n", prefixedName)
        writer write ("  init: super func\n")
        instance writePrologue(trail, writer)

        writer write ("  parse: static func (_reader: GrammarReader) -> Token {\n")
        writer write ("     _start: Long  = _reader marker\n")
        writer write ("     _end: Long  = -1\n")
        instance writeInSitu(trail, writer)
        writer write ("     new(_reader, _start, _end)\n")
        writer write ("  }\n")
        writer write ("}\n\n")

        writer close()
    }

}

/**
 * "some string here"
 * matches the string exactly or nothing
 */
SymbolRule: class extends Rule {

    symbol: String

    init: func(=symbol) {}

    toString: func -> String { "\"%s\"" format(symbol) }
    
    resolve: func (g: Grammar) {
        // nothing to do
    }

    writePrologue: func (trail: Trail, writer: Writer) {
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        writer writef("     // symbol rule %s\n", toString())
        writer writef("     for(c in \"%s\") if(_reader read() != c) {\n", symbol)
        writer write ("       _reader reset(_start)\n")
        writer write ("       return null\n")
        writer write ("     }\n")
        writer write ("     _end = _reader mark()\n")
    }

}

InstanceRule: class extends Rule {

    refName: String
    ref: Rule
    params := ArrayList<Rule> new()

    init: func (=refName) {}

    toString: func -> String {
        paramRepr := params empty?() ? "" : "<" + params map(|x| x _) join(", ") + ">"
        "%s%s" format(refName, paramRepr)
    }

    resolve: func (g: Grammar) {
        ref = g rules[refName]
        if(!ref) {
            // This currently fail on generic parameters - we need some kind of stack here
            //Exception new("Undefined rule %s" format(refName)) throw()
        }
    }

}

NamedRule: class extends Rule {

    name: String
    instance: Rule

    init: func(=name, =instance)

    toString: func -> String {
        "%s:%s" format(name, instance _)
    }

    resolve: func (g: Grammar) {
        instance resolve(g)
    }

}

RegexpRule: class extends Rule {

    expr: String

    init: func(=expr) {}

    toString: func -> String {
        expr
    }

    resolve: func (g: Grammar) {
        // nothing to resolve here.
    }

}

/**
 * somerule? 
 * matches the rule exactly once or none at all
 */
ZeroOrOne: class extends Rule {

    rule: Rule

    init: func(=rule) {}

    toString: func -> String {
        "%s?" format(rule _)
    }

    resolve: func (g: Grammar) {
        rule resolve(g)
    }
}

/**
 * somerule*
 * matches the rule from zero to infinite times
 * note that matching it infinite times might take
 * a non-finite amount of time to complete. Your call.
 */
ZeroOrMore: class extends Rule {

    rule: Rule

    init: func(=rule) {}

    toString: func -> String {
        "%s*" format(rule _)
    }

    resolve: func (g: Grammar) {
        rule resolve(g)
    }

}

/**
 * somerule | someotherrule
 * Must match somerule, or someotherrule
 */
OrRule: class extends Rule {

    leftRule, rightRule: Rule

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s | %s" format(leftRule _, rightRule _)
    }

    resolve: func (g: Grammar) {
        leftRule resolve(g)
        rightRule resolve(g)
    }

}

/**
 * somerule someotherrule
 * Must match somerule, then someotherrule
 */
AndRule: class extends Rule {

    leftRule, rightRule: Rule
    sub1, sub2: String

    init: func(=leftRule, =rightRule) {}

    toString: func -> String {
        "%s %s" format(leftRule _, rightRule _)
    }

    resolve: func (g: Grammar) {
        leftRule resolve(g)
        rightRule resolve(g)
    }

    writePrologue: func (trail: Trail, writer: Writer) {
        sub1 = writeSub(trail, writer, leftRule)
        sub2 = writeSub(trail, writer, rightRule)
    }

    writeInSitu: func (trail: Trail, writer: Writer) {
        tok1 := genName()
        tok2 := genName()
        writer writef("%s := %s(_reader)\n", tok1, sub1)
        writer writef("if(%s) {\n", tok1)
        writer writef("  %s := %s(_reader)\n", tok2, sub2)
        writer writef("  if(%s) return %s merge(%s)\n", tok2, tok1, tok2)
        writer write ("}\n")
        writer write ("return null\n")
    }

}

Grammar: class {

    // ----- Regular expressions
    word := Regexp compile("[A-Za-z\\-]*")
    wordColon := Regexp compile("([A-Za-z\\-]*):")
    allWs := Regexp compile("[ \t\n]*") 
    ws := Regexp compile("[ \t]*")
    assDecl := Regexp compile(":=[ \t]*")
    comma := Regexp compile(",[ \t]*")

    // ----- Grammar content
    path: String
    rules := HashMap<String, TopRule> new()
    reader: GrammarReader

    init: func (=path, params: BuildParams) {
        reader = GrammarReader new(File new(path) read())
        readTopLevels()

        for(rule in rules) {
            rule resolve(this)
        }

        for(rule in rules) {
            rule writeFile(this, params)
        }

        ["Token", "GrammarReader"] as ArrayList<String> each(|builtin|
            File new(params distrib, "source/herge/%s.ooc" format(builtin)) copyTo(File new(params outPath, builtin + ".ooc"))
        )
    }

    readTopLevels: func {
        while (true) {
            skipAllWhitespace()
            if(!reader hasNext?()) return
            if(reader peek() == '#') {
                reader readLine()
                continue
            }

            name := reader readRegexp(word)
            if(name empty?()) reader error("Expected toplevel rule name")

            params: ArrayList<String>

            skipWhitespace()
            if(reader peek() == '<') {
                reader read()
                paramString := reader readUntil('>') 
                params = GrammarReader new(paramString) readCommaList()
            }


            skipWhitespace()
            if (!reader readRegexp(assDecl)) reader error("Expected ':=' here")

            skipWhitespace()
            instance := readRule()
            if(!instance) reader error("Expected instance here")

            rule := TopRule new(name, params, instance)
            ">> %s" printfln(rule _)
            rules put(name, rule)
        }
    }

    readRule: func -> Rule {
        ruleName := reader readRegexp(wordColon, 1)
        skipWhitespace()

        rule := match (reader peek()) {
            case '"' =>
                reader read()
                SymbolRule new(reader readUntil('"')) 
            case '[' =>
                reader read()
                expr := "[%s]" format(reader readUntil(']'))
                RegexpRule new(expr)
            case '(' =>
                "Reading paren" println()
                reader read()
                rule := readRule() 
                skipWhitespace()
                if(reader read() != ')') reader error("Expected closing parenthesis")
                rule
             case =>
                instanceName := reader readRegexp(word)
                "Got instanceName %s" printfln(instanceName)
                if(instanceName empty?()) reader error("Expected rule here")

                instance := InstanceRule new(instanceName)
                skipWhitespace()
                if(reader peek() == '<') {
                    reader read()
                    skipWhitespace()
                    while(reader peek() != '>') {
                        skipWhitespace()
                        instance params add(readRule())
                        if(!reader readRegexp(comma)) {
                            reader error("Invalid instance param list, expected comma")
                        }
                    }
                    if(reader read() != '>') reader error("Expected '>' here")
                }

                instance
        }

        if(ruleName && !ruleName empty?()) rule = NamedRule new(ruleName trim(':'), rule)

        "Just read %s %s" printfln(rule class name, rule _)

        while (true) {
            skipWhitespace()
            match (reader peek()) {
                case '*' => 
                    reader read()
                    rule = ZeroOrMore new(rule)
                case '?' =>
                    reader read()
                    rule = ZeroOrOne new(rule)
                case '|' =>
                    reader read()
                    skipWhitespace()
                    rightRule := readRule()
                    rule = OrRule new(rule, rightRule)
                case '\\' =>
                    skipAllWhitespace()
                case '\n' =>
                    break
                case '>' =>
                    break
                case ')' =>
                    break

                case =>
                    rightRule := readRule() 
                    rule = AndRule new(rule, rightRule)
            }
            "Just read %s %s" printfln(rule class name, rule _)
        }

        rule
    }

    skipWhitespace: func {
        reader readRegexp(ws)
    }

    skipAllWhitespace: func {
        reader readRegexp(allWs)
    }

}

BuildParams: class {
    outPath := "herge_output"
    prefix := ""
    distrib: String

    init: func (opts: Opts) {
        opts opts each(|key, value|
            match key {
                case "outpath" =>
                    outPath = value
                case "prefix" =>
                    prefix = value
                case =>
                    "Unknown option --%s" printfln(key)
            }
        )

        distrib = Env get("HERGE_DISTRIB")
        if(!distrib) {
            "Herge couldn't find its distribution folder - for now, please set the HERGE_DISTRIB environment variable to the folder containing source/" println()
            exit(1)
        }

    }
}

Herge: class {
    version := static "0.0"
}

main: func (mainArgs: ArrayList<String>) {

    opts := Opts new(mainArgs)

    params := BuildParams new(opts)
    opts args each(|arg|
        g := Grammar new(arg, params)
    )

}
